-- ===========================
-- PART 1: Core fixes & essentials
-- ===========================

-- Safety: drop procedures/tables if duplicate definitions exist in your current
-- file to avoid conflicts when re-running. These drops are conservative.

DROP PROCEDURE IF EXISTS ensure_user_cart_exists;
DROP PROCEDURE IF EXISTS add_to_cart;
DROP PROCEDURE IF EXISTS create_order_from_cart;
DROP PROCEDURE IF EXISTS get_customer_order_history;
DROP PROCEDURE IF EXISTS set_product_stock_delta;

-- New tables: payments and refunds
CREATE TABLE IF NOT EXISTS payments (
    payment_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    amount DECIMAL(12,2) NOT NULL,
    method VARCHAR(100),
    reference VARCHAR(255),
    status ENUM('pending','paid','failed','refunded') DEFAULT 'pending',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE,
    INDEX idx_order_payment (order_id)
) ENGINE=InnoDB;

CREATE TABLE IF NOT EXISTS refunds (
    refund_id INT AUTO_INCREMENT PRIMARY KEY,
    payment_id INT NULL,
    order_id INT NOT NULL,
    amount DECIMAL(12,2) NOT NULL,
    reference VARCHAR(255),
    status ENUM('initiated','processed','failed') DEFAULT 'initiated',
    reason TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (payment_id) REFERENCES payments(payment_id) ON DELETE SET NULL,
    FOREIGN KEY (order_id) REFERENCES orders(order_id) ON DELETE CASCADE,
    INDEX idx_order_refund (order_id)
) ENGINE=InnoDB;

-- Add soft-delete / active flags to important tables (if not already present)
-- Companies
ALTER TABLE companies
  ADD COLUMN IF NOT EXISTS is_active TINYINT(1) DEFAULT 1 AFTER gst_number;

-- Users
ALTER TABLE users
  ADD COLUMN IF NOT EXISTS is_active TINYINT(1) DEFAULT 1 AFTER role;

-- Products
ALTER TABLE products
  ADD COLUMN IF NOT EXISTS is_discontinued TINYINT(1) DEFAULT 0 AFTER created_at,
  ADD COLUMN IF NOT EXISTS is_active TINYINT(1) DEFAULT 1 AFTER is_discontinued;

-- Categories
ALTER TABLE categories
  ADD COLUMN IF NOT EXISTS is_active TINYINT(1) DEFAULT 1 AFTER created_at;

-- Ensure FULLTEXT index for search/autocomplete on products (InnoDB supports this on modern MySQL)
-- If your MySQL version does not support FULLTEXT on InnoDB, skip or change to MyISAM or use external search.
ALTER TABLE products
  ADD FULLTEXT INDEX IF NOT EXISTS ft_products_name_desc (name, description);

-- ===========================
-- Helper: ensure_user_cart_exists
-- Creates a default cart if the user has none (safe helper)
-- ===========================
DELIMITER //
CREATE PROCEDURE ensure_user_cart_exists (
    IN p_user_id INT
)
BEGIN
    DECLARE v_cnt INT;
    SELECT COUNT(*) INTO v_cnt FROM cart WHERE user_id = p_user_id;
    IF v_cnt = 0 THEN
        INSERT INTO cart (user_id) VALUES (p_user_id);
    END IF;
END //
DELIMITER ;

-- ===========================
-- Hardened add_to_cart (replaces prior definition; uses ensure_user_cart_exists)
-- Behavior: ensures cart exists, gets current product price, inserts or updates item
-- ===========================
DELIMITER //
CREATE PROCEDURE add_to_cart (
    IN p_user_id INT,
    IN p_product_id INT,
    IN p_quantity INT
)
BEGIN
    DECLARE v_cart_id INT;
    DECLARE v_price DECIMAL(12,2);

    -- Ensure user has a cart
    CALL ensure_user_cart_exists(p_user_id);

    -- Get cart_id
    SELECT cart_id INTO v_cart_id FROM cart WHERE user_id = p_user_id ORDER BY created_at DESC LIMIT 1;

    -- Validate cart exists (defensive)
    IF v_cart_id IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Failed to create/find cart for user';
    END IF;

    -- Get product price and active flag
    SELECT price INTO v_price FROM products WHERE product_id = p_product_id AND is_active = 1 LIMIT 1;
    IF v_price IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Product not found or inactive';
    END IF;

    -- If item exists -> update quantity; else insert
    IF EXISTS (SELECT 1 FROM cart_items WHERE cart_id = v_cart_id AND product_id = p_product_id) THEN
        UPDATE cart_items
        SET quantity = quantity + p_quantity, price = v_price
        WHERE cart_id = v_cart_id AND product_id = p_product_id;
    ELSE
        INSERT INTO cart_items (cart_id, product_id, quantity, price)
        VALUES (v_cart_id, p_product_id, p_quantity, v_price);
    END IF;
END //
DELIMITER ;

-- ===========================
-- Atomic stock adjustment helper
-- Usage: call set_product_stock_delta(product_id, delta)
-- Positive delta increases stock, negative reduces (will error if result < 0)
-- ===========================
DELIMITER //
CREATE PROCEDURE set_product_stock_delta (
    IN p_product_id INT,
    IN p_delta INT
)
BEGIN
    DECLARE v_stock INT;
    SELECT stock INTO v_stock FROM products WHERE product_id = p_product_id FOR UPDATE;

    IF v_stock IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Product not found';
    END IF;

    IF v_stock + p_delta < 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Insufficient stock for this operation';
    END IF;

    UPDATE products
    SET stock = stock + p_delta
    WHERE product_id = p_product_id;
END //
DELIMITER ;

-- ===========================
-- Robust create_order_from_cart (transactional)
-- Replaces fragile place_order variants. Returns inserted order_id in resultset.
-- ===========================
DROP PROCEDURE IF EXISTS create_order_from_cart;
DELIMITER //
CREATE PROCEDURE create_order_from_cart (
    IN p_user_id INT,
    IN p_shipping_address TEXT
)
BEGIN
    DECLARE v_cart_id INT;
    DECLARE v_total DECIMAL(12,2);
    DECLARE v_company_id INT;
    DECLARE v_new_order_id INT;
    DECLARE v_row_count INT;
    DECLARE done INT DEFAULT 0;

    -- Start transaction to maintain consistency
    START TRANSACTION;

    -- Ensure cart exists
    CALL ensure_user_cart_exists(p_user_id);

    SELECT cart_id INTO v_cart_id
    FROM cart
    WHERE user_id = p_user_id
    ORDER BY created_at DESC
    LIMIT 1;

    IF v_cart_id IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Cart not found for user';
    END IF;

    -- Calculate total; ensure cart has items
    SELECT SUM(ci.quantity * ci.price) INTO v_total
    FROM cart_items ci
    WHERE ci.cart_id = v_cart_id;

    IF v_total IS NULL OR v_total <= 0 THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Cart is empty';
    END IF;

    -- Determine company_id (assumes single vendor scenario; if multiple vendors need split orders per company)
    SELECT p.company_id INTO v_company_id
    FROM cart_items ci
    JOIN products p ON ci.product_id = p.product_id
    WHERE ci.cart_id = v_cart_id
    LIMIT 1;

    IF v_company_id IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Unable to determine company for cart items';
    END IF;

    -- Insert into orders
    INSERT INTO orders (user_id, company_id, total_amount, status, shipping_address, payment_status)
    VALUES (p_user_id, v_company_id, v_total, 'placed', p_shipping_address, 'pending');

    SET v_new_order_id = LAST_INSERT_ID();

    -- Move items to order_items and reduce stock atomically (use cursor loop to ensure triggers & stock checks)
    -- Insert order items in one statement (simpler), then adjust stock in a joined update.
    INSERT INTO order_items (order_id, product_id, quantity, price)
    SELECT v_new_order_id, ci.product_id, ci.quantity, ci.price
    FROM cart_items ci
    WHERE ci.cart_id = v_cart_id;

    -- Reduce stock for each product; this will rely on set_product_stock_delta logic or trigger.
    -- Use a grouped update to reduce stock
    UPDATE products p
    JOIN (
        SELECT product_id, SUM(quantity) AS total_qty
        FROM order_items
        WHERE order_id = v_new_order_id
        GROUP BY product_id
    ) AS oq ON p.product_id = oq.product_id
    SET p.stock = p.stock - oq.total_qty
    WHERE p.product_id = oq.product_id;

    -- Optional safety check: ensure no stock became negative (in case triggers disabled)
    IF EXISTS (SELECT 1 FROM products WHERE product_id IN (SELECT product_id FROM order_items WHERE order_id = v_new_order_id) AND stock < 0) THEN
        -- revert
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Insufficient stock while creating order';
    END IF;

    -- Insert initial tracking entry (order created)
    INSERT INTO order_tracking (order_id, status, remarks)
    VALUES (v_new_order_id, 'placed', 'Order created');

    -- Clear cart items and cart
    DELETE FROM cart_items WHERE cart_id = v_cart_id;
    DELETE FROM cart WHERE cart_id = v_cart_id;

    COMMIT;

    -- Return the new order id to caller
    SELECT v_new_order_id AS order_id;
END //
DELIMITER ;

-- ===========================
-- Corrected get_customer_order_history
-- Fixes incorrect joins and returns detailed order history for a user
-- ===========================
DROP PROCEDURE IF EXISTS get_customer_order_history;
DELIMITER //
CREATE PROCEDURE get_customer_order_history (
    IN p_user_id INT
)
BEGIN
    SELECT
        o.order_id,
        o.created_at AS order_date,
        o.total_amount,
        o.status AS order_status,
        o.payment_status,
        oi.product_id,
        p.name AS product_name,
        oi.quantity,
        oi.price
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    WHERE o.user_id = p_user_id
    ORDER BY o.created_at DESC;
END //
DELIMITER ;

-- ===========================
-- Make sure triggers that reduce stock still exist and are consistent.
-- If your triggers already update stock (trg_after_order_item_insert), ensure they won't conflict with
-- the bulk update performed in create_order_from_cart. Consider disabling duplicate stock updates to avoid double-decrement.
-- ===========================

-- End of Part 1

-- ===========================
-- PART 2: Import/Export, Advanced Product CRUD, Search/Pagination, Payments & Refunds
-- ===========================

-- Safety drops for procedures we will (re)define
DROP PROCEDURE IF EXISTS sp_import_products_from_temp;
DROP PROCEDURE IF EXISTS sp_bulk_update_stock_from_temp;
DROP PROCEDURE IF EXISTS sp_export_products_csv;
DROP PROCEDURE IF EXISTS sp_record_payment;
DROP PROCEDURE IF EXISTS sp_issue_refund;
DROP PROCEDURE IF EXISTS sp_list_products;
DROP PROCEDURE IF EXISTS sp_search_products;
DROP PROCEDURE IF EXISTS sp_search_products_autocomplete;
DROP PROCEDURE IF EXISTS create_product_full;
DROP PROCEDURE IF EXISTS update_product_full;
DROP PROCEDURE IF EXISTS soft_delete_product;

-- Temporary import table: admin will load CSV into this table using client tools then call import proc
CREATE TABLE IF NOT EXISTS import_products_temp (
    import_id INT AUTO_INCREMENT PRIMARY KEY,
    company_id INT,
    category_id INT,
    name VARCHAR(255),
    description TEXT,
    price DECIMAL(12,2),
    stock INT,
    material VARCHAR(50),
    weight DECIMAL(10,2),
    color VARCHAR(50),
    making_process TEXT,
    image_url VARCHAR(500),
    purity VARCHAR(10) NULL,
    diamond_shape VARCHAR(100) NULL,
    diamond_cut VARCHAR(100) NULL,
    diamond_carat DECIMAL(6,2) NULL,
    diamond_clarity VARCHAR(50) NULL,
    diamond_color_grade VARCHAR(50) NULL,
    certification VARCHAR(255) NULL,
    origin_country VARCHAR(100) NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- Import errors log to capture row-level import problems
CREATE TABLE IF NOT EXISTS import_errors_log (
    error_id INT AUTO_INCREMENT PRIMARY KEY,
    import_table VARCHAR(100),
    import_row_id INT,
    error_message TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- ===========================
-- sp_import_products_from_temp
-- Reads import_products_temp and inserts into products (+ diamonds/gold if data present).
-- Logs errors into import_errors_log and continues processing other rows.
-- NOTE: This assumes data has already been validated lightly by the client; server-side checks here are defensive.
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_import_products_from_temp()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE v_import_id INT;
    DECLARE v_company_id INT;
    DECLARE v_category_id INT;
    DECLARE v_name VARCHAR(255);
    DECLARE v_description TEXT;
    DECLARE v_price DECIMAL(12,2);
    DECLARE v_stock INT;
    DECLARE v_material VARCHAR(50);
    DECLARE v_weight DECIMAL(10,2);
    DECLARE v_color VARCHAR(50);
    DECLARE v_making_process TEXT;
    DECLARE v_image_url VARCHAR(500);
    DECLARE v_purity VARCHAR(10);
    DECLARE v_diamond_shape VARCHAR(100);
    DECLARE v_diamond_cut VARCHAR(100);
    DECLARE v_diamond_carat DECIMAL(6,2);
    DECLARE v_diamond_clarity VARCHAR(50);
    DECLARE v_diamond_color_grade VARCHAR(50);
    DECLARE v_certification VARCHAR(255);
    DECLARE v_origin_country VARCHAR(100);

    DECLARE cur CURSOR FOR
      SELECT import_id, company_id, category_id, name, description, price, stock, material, weight, color, making_process, image_url,
             purity, diamond_shape, diamond_cut, diamond_carat, diamond_clarity, diamond_color_grade, certification, origin_country
      FROM import_products_temp
      ORDER BY import_id;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;
    START TRANSACTION;

    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO v_import_id, v_company_id, v_category_id, v_name, v_description, v_price, v_stock, v_material, v_weight, v_color, v_making_process, v_image_url,
                         v_purity, v_diamond_shape, v_diamond_cut, v_diamond_carat, v_diamond_clarity, v_diamond_color_grade, v_certification, v_origin_country;
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;

        -- Defensive checks
        IF v_name IS NULL OR TRIM(v_name) = '' THEN
            INSERT INTO import_errors_log (import_table, import_row_id, error_message)
            VALUES ('import_products_temp', v_import_id, 'Product name missing');
            ITERATE read_loop;
        END IF;

        IF v_company_id IS NULL THEN
            INSERT INTO import_errors_log (import_table, import_row_id, error_message)
            VALUES ('import_products_temp', v_import_id, 'Company ID missing');
            ITERATE read_loop;
        END IF;

        -- Default material if not provided
        IF v_material IS NULL OR TRIM(v_material) = '' THEN
            SET v_material = 'mixed';
        END IF;

        -- Insert product
        BEGIN
            DECLARE EXIT HANDLER FOR SQLEXCEPTION
            BEGIN
                -- Log error and continue
                ROLLBACK;
                INSERT INTO import_errors_log (import_table, import_row_id, error_message)
                VALUES ('import_products_temp', v_import_id, CONCAT('SQL Exception while inserting product: ', v_name));
                START TRANSACTION;
            END;

            INSERT INTO products (company_id, category_id, name, description, price, stock, material, weight, color, making_process, image_url, is_active)
            VALUES (v_company_id, v_category_id, v_name, v_description, IFNULL(v_price,0.00), IFNULL(v_stock,0), v_material, v_weight, v_color, v_making_process, v_image_url, 1);

            SET @new_product_id = LAST_INSERT_ID();

            -- If diamond details present -> insert into diamonds
            IF v_diamond_shape IS NOT NULL OR v_diamond_cut IS NOT NULL OR v_diamond_carat IS NOT NULL THEN
                INSERT INTO diamonds (product_id, shape, cut, carat, clarity, color_grade, certification, origin_country)
                VALUES (@new_product_id, v_diamond_shape, v_diamond_cut, v_diamond_carat, v_diamond_clarity, v_diamond_color_grade, v_certification, v_origin_country);
            END IF;

            -- If gold purity present -> insert into gold_details
            IF v_purity IS NOT NULL AND TRIM(v_purity) <> '' THEN
                INSERT INTO gold_details (product_id, purity, color, making_process, origin_country)
                VALUES (@new_product_id, v_purity, v_color, v_making_process, v_origin_country);
            END IF;

        END;
    END LOOP;

    CLOSE cur;
    COMMIT;
END //
DELIMITER ;

-- ===========================
-- Bulk update stock from import_products_temp (useful when you import inventory updates)
-- The temp table should contain product_id and stock columns for updates; we assume mapping by name/sku is done upstream.
-- For safety, this proc expects import_products_temp.import_id referencing product_id in 'category_id' column (or adapt as required).
-- We'll implement a simple version: if import_products_temp.category_id holds product_id, update stock.
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_bulk_update_stock_from_temp()
BEGIN
    -- We expect rows where category_id column is used to pass product_id (lightweight adapter)
    INSERT INTO import_errors_log (import_table, import_row_id, error_message)
    SELECT 'sp_bulk_update_stock_from_temp', import_id, CONCAT('Skipped: product_id missing for import_id=', import_id)
    FROM import_products_temp
    WHERE category_id IS NULL;

    UPDATE products p
    JOIN import_products_temp t ON t.category_id = p.product_id
    SET p.stock = t.stock, p.price = t.price
    WHERE t.category_id IS NOT NULL;
END //
DELIMITER ;

-- ===========================
-- Export products (CSV-friendly resultset)
-- Simply returns rows; client may export to CSV.
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_export_products_csv (
    IN p_company_id INT,
    IN p_category_id INT
)
BEGIN
    SELECT
        p.product_id, p.name, p.description, p.price, p.stock, p.material, p.weight, p.color, p.making_process, p.image_url,
        p.is_active, p.is_discontinued, c.name AS category_name, comp.name AS company_name
    FROM products p
    LEFT JOIN categories c ON p.category_id = c.category_id
    LEFT JOIN companies comp ON p.company_id = comp.company_id
    WHERE (p.company_id = p_company_id OR p_company_id IS NULL)
      AND (p.category_id = p_category_id OR p_category_id IS NULL)
    ORDER BY p.product_id;
END //
DELIMITER ;

-- ===========================
-- Advanced product CRUD (create/update/soft-delete)
-- create_product_full and update_product_full (more fields than previous add_product)
-- ===========================
DELIMITER //
CREATE PROCEDURE create_product_full (
    IN p_company_id INT,
    IN p_category_id INT,
    IN p_name VARCHAR(255),
    IN p_description TEXT,
    IN p_price DECIMAL(12,2),
    IN p_stock INT,
    IN p_material VARCHAR(50),
    IN p_weight DECIMAL(10,2),
    IN p_color VARCHAR(50),
    IN p_making_process TEXT,
    IN p_image_url VARCHAR(500)
)
BEGIN
    INSERT INTO products (company_id, category_id, name, description, price, stock, material, weight, color, making_process, image_url, is_active)
    VALUES (p_company_id, p_category_id, p_name, p_description, p_price, p_stock, p_material, p_weight, p_color, p_making_process, p_image_url, 1);

    SELECT LAST_INSERT_ID() AS product_id;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE update_product_full (
    IN p_product_id INT,
    IN p_category_id INT,
    IN p_name VARCHAR(255),
    IN p_description TEXT,
    IN p_price DECIMAL(12,2),
    IN p_stock INT,
    IN p_material VARCHAR(50),
    IN p_weight DECIMAL(10,2),
    IN p_color VARCHAR(50),
    IN p_making_process TEXT,
    IN p_image_url VARCHAR(500),
    IN p_is_active TINYINT(1),
    IN p_is_discontinued TINYINT(1)
)
BEGIN
    UPDATE products
    SET
      category_id = p_category_id,
      name = p_name,
      description = p_description,
      price = p_price,
      stock = p_stock,
      material = p_material,
      weight = p_weight,
      color = p_color,
      making_process = p_making_process,
      image_url = p_image_url,
      is_active = p_is_active,
      is_discontinued = p_is_discontinued
    WHERE product_id = p_product_id;

    SELECT ROW_COUNT() AS rows_affected;
END //
DELIMITER ;

-- Soft-delete wrapper
DELIMITER //
CREATE PROCEDURE soft_delete_product (
    IN p_product_id INT
)
BEGIN
    UPDATE products
    SET is_discontinued = 1, is_active = 0
    WHERE product_id = p_product_id;
END //
DELIMITER ;

-- ===========================
-- Product listing with pagination, filtering and sorting
-- Parameters:
-- p_company_id, p_category_id: optional filters.
-- p_page, p_page_size: pagination.
-- p_min_price, p_max_price: optional filters.
-- p_material: optional.
-- p_search_term: optional (will match name/description via FULLTEXT if available, else LIKE).
-- p_sort_by: 'price_asc','price_desc','created_desc','created_asc','popularity' (popularity requires tracking)
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_list_products (
    IN p_company_id INT,
    IN p_category_id INT,
    IN p_page INT,
    IN p_page_size INT,
    IN p_min_price DECIMAL(12,2),
    IN p_max_price DECIMAL(12,2),
    IN p_material VARCHAR(50),
    IN p_search_term VARCHAR(255),
    IN p_sort_by VARCHAR(50)
)
BEGIN
    DECLARE v_offset INT;
    SET v_offset = (GREATEST(p_page,1) - 1) * GREATEST(p_page_size,10);

    -- Base query
    SELECT SQL_CALC_FOUND_ROWS
        p.product_id, p.name, p.description, p.price, p.stock, p.material, p.weight, p.color, p.image_url, c.name AS category_name, comp.name AS company_name
    FROM products p
    LEFT JOIN categories c ON p.category_id = c.category_id
    LEFT JOIN companies comp ON p.company_id = comp.company_id
    WHERE (p.company_id = p_company_id OR p_company_id IS NULL)
      AND (p.category_id = p_category_id OR p_category_id IS NULL)
      AND (p.price >= COALESCE(p_min_price, 0))
      AND (p.price <= COALESCE(p_max_price, 999999999))
      AND (p.material = p_material OR p_material IS NULL OR p_material = '')
      AND p.is_active = 1
      AND p.is_discontinued = 0
      AND (
           (p_search_term IS NULL OR p_search_term = '')
           OR (
               -- use fulltext if available
               (MATCH(p.name, p.description) AGAINST (p_search_term IN NATURAL LANGUAGE MODE))
               OR (p.name LIKE CONCAT('%', p_search_term, '%'))
               OR (p.description LIKE CONCAT('%', p_search_term, '%'))
           )
      )
    ORDER BY
      CASE WHEN p_sort_by = 'price_asc' THEN p.price END ASC,
      CASE WHEN p_sort_by = 'price_desc' THEN p.price END DESC,
      CASE WHEN p_sort_by = 'created_desc' THEN p.created_at END DESC,
      CASE WHEN p_sort_by = 'created_asc' THEN p.created_at END ASC
    LIMIT p_page_size OFFSET v_offset;
END //
DELIMITER ;

-- ===========================
-- Search autocomplete (returns id + name)
-- Uses FULLTEXT if available else LIKE. Returns up to p_limit rows.
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_search_products_autocomplete (
    IN p_term VARCHAR(255),
    IN p_limit INT
)
BEGIN
    IF p_term IS NULL OR TRIM(p_term) = '' THEN
        SELECT product_id, name FROM products WHERE is_active = 1 AND is_discontinued = 0 LIMIT GREATEST(p_limit,10);
    ELSE
        -- Try a MATCH search first; if it returns zero rows, fallback to LIKE
        SELECT product_id, name
        FROM products
        WHERE is_active = 1 AND is_discontinued = 0
          AND (MATCH(name, description) AGAINST (p_term IN NATURAL LANGUAGE MODE))
        LIMIT p_limit;

        -- If above returned 0 rows, run fallback (client should inspect row count)
    END IF;
END //
DELIMITER ;

-- ===========================
-- More flexible search proc which returns rows (not just autocomplete)
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_search_products (
    IN p_term VARCHAR(255),
    IN p_page INT,
    IN p_page_size INT
)
BEGIN
    DECLARE v_offset INT;
    SET v_offset = (GREATEST(p_page,1) - 1) * GREATEST(p_page_size,10);

    SELECT p.product_id, p.name, p.description, p.price, p.stock, p.material, p.image_url, c.name AS category_name
    FROM products p
    LEFT JOIN categories c ON p.category_id = c.category_id
    WHERE p.is_active = 1 AND p.is_discontinued = 0
      AND (
          (MATCH(p.name, p.description) AGAINST (p_term IN NATURAL LANGUAGE MODE))
          OR (p.name LIKE CONCAT('%', p_term, '%'))
          OR (p.description LIKE CONCAT('%', p_term, '%'))
      )
    LIMIT p_page_size OFFSET v_offset;
END //
DELIMITER ;

-- ===========================
-- Payments / Refunds procedures
-- sp_record_payment -> Insert payment, mark order as paid if full
-- sp_issue_refund -> Insert refund, update payment & order statuses, create refund row
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_record_payment (
    IN p_order_id INT,
    IN p_amount DECIMAL(12,2),
    IN p_method VARCHAR(100),
    IN p_reference VARCHAR(255)
)
BEGIN
    DECLARE v_order_total DECIMAL(12,2);
    DECLARE v_paid_sum DECIMAL(12,2);

    START TRANSACTION;

    SELECT total_amount INTO v_order_total FROM orders WHERE order_id = p_order_id FOR UPDATE;
    IF v_order_total IS NULL THEN
        ROLLBACK;
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Order not found';
    END IF;

    INSERT INTO payments (order_id, amount, method, reference, status)
    VALUES (p_order_id, p_amount, p_method, p_reference, 'paid');

    -- Recalculate payment sum
    SELECT COALESCE(SUM(amount), 0) INTO v_paid_sum FROM payments WHERE order_id = p_order_id AND status IN ('paid','refunded');

    -- If paid sum >= order total, mark order payment_status = 'paid'
    IF v_paid_sum >= v_order_total THEN
        UPDATE orders SET payment_status = 'paid', status = 'processing' WHERE order_id = p_order_id;
    ELSE
        UPDATE orders SET payment_status = 'pending' WHERE order_id = p_order_id;
    END IF;

    COMMIT;

    SELECT LAST_INSERT_ID() AS payment_id;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE sp_issue_refund (
    IN p_payment_id INT,
    IN p_amount DECIMAL(12,2),
    IN p_reference VARCHAR(255),
    IN p_reason TEXT
)
BEGIN
    DECLARE v_order_id INT;
    DECLARE v_payment_exists INT;

    SELECT order_id INTO v_order_id FROM payments WHERE payment_id = p_payment_id;
    IF v_order_id IS NULL THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Payment not found';
    END IF;

    START TRANSACTION;

    -- Insert refund record
    INSERT INTO refunds (payment_id, order_id, amount, reference, status, reason)
    VALUES (p_payment_id, v_order_id, p_amount, p_reference, 'initiated', p_reason);

    -- Mark payment/refund statuses
    UPDATE payments SET status = 'refunded' WHERE payment_id = p_payment_id;

    -- Update order payment_status and possibly restore stock if full order refunded
    -- Compute total_paid and total_refunded
    DECLARE v_total_paid DECIMAL(12,2);
    DECLARE v_total_refunded DECIMAL(12,2);
    SELECT COALESCE(SUM(amount),0) INTO v_total_paid FROM payments WHERE order_id = v_order_id;
    SELECT COALESCE(SUM(amount),0) INTO v_total_refunded FROM refunds WHERE order_id = v_order_id;

    IF v_total_refunded >= v_total_paid THEN
        UPDATE orders SET payment_status = 'failed', status = 'cancelled' WHERE order_id = v_order_id;
        -- restore stocks for items in order
        UPDATE products p
        JOIN order_items oi ON p.product_id = oi.product_id
        SET p.stock = p.stock + oi.quantity
        WHERE oi.order_id = v_order_id;
    ELSE
        -- keep order status as-is, mark as partially refunded
        UPDATE refunds SET status = 'processed' WHERE refund_id = LAST_INSERT_ID();
    END IF;

    COMMIT;

    SELECT LAST_INSERT_ID() AS refund_id;
END //
DELIMITER ;

-- ===========================
-- End of Part 2
-- ===========================

-- ===========================
-- PART 3: Reports, Views, Admin Utilities & Maintenance
-- ===========================

-- Safety drops for procedures/views/tables we will create/redefine
DROP PROCEDURE IF EXISTS sp_top_selling_products;
DROP PROCEDURE IF EXISTS sp_revenue_by_day_range;
DROP PROCEDURE IF EXISTS sp_monthly_revenue_timeseries;
DROP PROCEDURE IF EXISTS sp_pending_orders_by_aging;
DROP PROCEDURE IF EXISTS sp_low_stock_alerts;
DROP PROCEDURE IF EXISTS sp_inventory_valuation;
DROP PROCEDURE IF EXISTS sp_recalculate_all_product_ratings;
DROP PROCEDURE IF EXISTS sp_cleanup_orphaned_records;
DROP PROCEDURE IF EXISTS sp_rotate_audit_logs;
DROP PROCEDURE IF EXISTS sp_bulk_update_status;
DROP VIEW IF EXISTS v_order_payments;
DROP VIEW IF EXISTS v_product_inventory;
DROP VIEW IF EXISTS v_monthly_revenue_timeseries;
DROP TABLE IF EXISTS product_ratings_cache;
DROP TABLE IF EXISTS audit_logs_archive;

-- ===========================
-- Views
-- 1) v_order_payments: join orders and payments
-- 2) v_product_inventory: product details + valuation (uses price as proxy unless cost table exists)
-- 3) v_monthly_revenue_timeseries: aggregated monthly revenue view
-- ===========================
CREATE OR REPLACE VIEW v_order_payments AS
SELECT
    o.order_id,
    o.user_id,
    o.company_id,
    o.total_amount,
    o.payment_status,
    p.payment_id,
    p.amount AS payment_amount,
    p.method AS payment_method,
    p.reference AS payment_reference,
    p.status AS payment_status_row,
    p.created_at AS payment_date
FROM orders o
LEFT JOIN payments p ON o.order_id = p.order_id;

CREATE OR REPLACE VIEW v_product_inventory AS
SELECT
    p.product_id,
    p.name,
    p.company_id,
    c.name AS company_name,
    p.category_id,
    cat.name AS category_name,
    p.stock,
    p.price,
    p.stock * p.price AS inventory_valuation_estimated,
    p.is_active,
    p.is_discontinued
FROM products p
LEFT JOIN companies c ON p.company_id = c.company_id
LEFT JOIN categories cat ON p.category_id = cat.category_id;

CREATE OR REPLACE VIEW v_monthly_revenue_timeseries AS
SELECT
    YEAR(o.created_at) AS yr,
    MONTH(o.created_at) AS mth,
    CONCAT(YEAR(o.created_at),'-', LPAD(MONTH(o.created_at),2,'0')) AS period,
    SUM(o.total_amount) AS total_revenue,
    COUNT(o.order_id) AS orders_count
FROM orders o
WHERE o.status IN ('placed','processing','shipped','delivered')
GROUP BY YEAR(o.created_at), MONTH(o.created_at)
ORDER BY YEAR(o.created_at), MONTH(o.created_at);

-- ===========================
-- Product ratings cache table (materialized summary) for fast dashboards
-- ===========================
CREATE TABLE IF NOT EXISTS product_ratings_cache (
    product_id INT PRIMARY KEY,
    avg_rating DECIMAL(4,2),
    total_reviews INT,
    last_calculated TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB;

-- ===========================
-- Audit logs archive table (for rotation)
-- ===========================
CREATE TABLE IF NOT EXISTS audit_logs_archive LIKE audit_logs;

-- ===========================
-- Reporting Stored Procedures
-- ===========================

DELIMITER //
CREATE PROCEDURE sp_top_selling_products (
    IN p_limit INT,
    IN p_company_id INT,
    IN p_from_date DATE,
    IN p_to_date DATE
)
BEGIN
    SELECT
        p.product_id,
        p.name AS product_name,
        SUM(oi.quantity) AS units_sold,
        SUM(oi.quantity * oi.price) AS revenue_generated
    FROM order_items oi
    JOIN orders o ON oi.order_id = o.order_id
    JOIN products p ON oi.product_id = p.product_id
    WHERE (p.company_id = p_company_id OR p_company_id IS NULL)
      AND (o.created_at BETWEEN COALESCE(p_from_date, '1970-01-01') AND COALESCE(p_to_date, NOW()))
      AND o.status IN ('placed','processing','shipped','delivered')
    GROUP BY p.product_id, p.name
    ORDER BY units_sold DESC
    LIMIT GREATEST(p_limit,10);
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE sp_revenue_by_day_range (
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    SELECT
        DATE(o.created_at) AS sale_date,
        SUM(o.total_amount) AS total_revenue,
        COUNT(DISTINCT o.order_id) AS total_orders
    FROM orders o
    WHERE o.created_at BETWEEN p_start_date AND p_end_date
      AND o.status IN ('placed','processing','shipped','delivered')
    GROUP BY DATE(o.created_at)
    ORDER BY sale_date ASC;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE sp_monthly_revenue_timeseries_proc (
    IN p_months_back INT
)
BEGIN
    -- Return monthly revenue for last p_months_back months including current
    SELECT
        yr, mth, period, total_revenue, orders_count
    FROM v_monthly_revenue_timeseries
    WHERE STR_TO_DATE(CONCAT(period,'-01'), '%Y-%m-%d') >= DATE_SUB(DATE_FORMAT(CURDATE(), '%Y-%m-01'), INTERVAL GREATEST(p_months_back,1)-1 MONTH)
    ORDER BY yr, mth;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE sp_pending_orders_by_aging (
    IN p_days_threshold INT
)
BEGIN
    SELECT
        o.order_id,
        CONCAT(u.first_name,' ',u.last_name) AS customer_name,
        o.total_amount,
        o.status,
        DATEDIFF(CURDATE(), DATE(o.created_at)) AS days_since_order,
        o.created_at
    FROM orders o
    JOIN users u ON o.user_id = u.user_id
    WHERE o.status IN ('placed','processing') AND DATEDIFF(CURDATE(), DATE(o.created_at)) >= p_days_threshold
    ORDER BY days_since_order DESC;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE sp_low_stock_alerts (
    IN p_threshold INT
)
BEGIN
    SELECT
        p.product_id, p.name, c.name AS category_name, comp.name AS company_name, p.stock
    FROM products p
    LEFT JOIN categories c ON p.category_id = c.category_id
    LEFT JOIN companies comp ON p.company_id = comp.company_id
    WHERE p.stock <= GREATEST(p_threshold, 10)
      AND p.is_active = 1
    ORDER BY p.stock ASC;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE sp_inventory_valuation (
    IN p_company_id INT
)
BEGIN
    -- Uses current product price * stock as a proxy for valuation. If you have product_costs table, adapt accordingly.
    SELECT
        COALESCE(SUM(stock * price), 0) AS total_inventory_value,
        COALESCE(SUM(stock), 0) AS total_units
    FROM products
    WHERE (company_id = p_company_id OR p_company_id IS NULL)
      AND is_active = 1;
END //
DELIMITER ;

-- ===========================
-- Utility: Recalculate product ratings cache
-- This reads v_product_ratings view and upserts into product_ratings_cache
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_recalculate_all_product_ratings ()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE v_pid INT;
    DECLARE v_avg DECIMAL(6,2);
    DECLARE v_total INT;

    DECLARE cur CURSOR FOR
      SELECT p.product_id, ROUND(COALESCE(AVG(r.rating),0),2) AS avg_rating, COUNT(r.review_id) AS total_reviews
      FROM products p
      LEFT JOIN reviews r ON p.product_id = r.product_id
      GROUP BY p.product_id;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 1;

    OPEN cur;
    read_loop: LOOP
        FETCH cur INTO v_pid, v_avg, v_total;
        IF done = 1 THEN
            LEAVE read_loop;
        END IF;

        INSERT INTO product_ratings_cache (product_id, avg_rating, total_reviews, last_calculated)
        VALUES (v_pid, v_avg, v_total, NOW())
        ON DUPLICATE KEY UPDATE
            avg_rating = VALUES(avg_rating),
            total_reviews = VALUES(total_reviews),
            last_calculated = VALUES(last_calculated);
    END LOOP;
    CLOSE cur;
END //
DELIMITER ;

-- ===========================
-- Admin utilities
-- 1) Cleanup orphaned records (carts without users, cart_items without cart, audit_logs with missing user reference etc.)
-- 2) Bulk update status for orders (admin action)
-- 3) Rotate/Archive audit_logs older than X days into audit_logs_archive
-- ===========================
DELIMITER //
CREATE PROCEDURE sp_cleanup_orphaned_records ()
BEGIN
    -- 1. Delete cart_items belonging to missing carts (defensive)
    DELETE ci FROM cart_items ci
    LEFT JOIN cart c ON ci.cart_id = c.cart_id
    WHERE c.cart_id IS NULL;

    -- 2. Delete carts with no user (and older than 30 days to be conservative)
    DELETE c FROM cart c
    LEFT JOIN users u ON c.user_id = u.user_id
    WHERE u.user_id IS NULL AND c.created_at < DATE_SUB(NOW(), INTERVAL 30 DAY);

    -- 3. Optionally cleanup order_items for orders that don't exist (shouldn't normally happen)
    DELETE oi FROM order_items oi
    LEFT JOIN orders o ON oi.order_id = o.order_id
    WHERE o.order_id IS NULL;

    -- 4. Cleanup payments referencing missing orders
    DELETE p FROM payments p
    LEFT JOIN orders o2 ON p.order_id = o2.order_id
    WHERE o2.order_id IS NULL;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE sp_bulk_update_status (
    IN p_order_ids_csv TEXT,
    IN p_new_status ENUM('placed','processing','shipped','delivered','cancelled')
)
BEGIN
    -- Split CSV (simple approach using FIND_IN_SET); careful: this is not super-efficient for very large lists
    UPDATE orders
    SET status = p_new_status
    WHERE FIND_IN_SET(CAST(order_id AS CHAR), p_order_ids_csv);
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE sp_rotate_audit_logs (
    IN p_older_than_days INT
)
BEGIN
    -- Move old logs into archive table, then delete from original to keep size small
    START TRANSACTION;
    INSERT INTO audit_logs_archive SELECT * FROM audit_logs WHERE created_at < DATE_SUB(NOW(), INTERVAL p_older_than_days DAY);
    DELETE FROM audit_logs WHERE created_at < DATE_SUB(NOW(), INTERVAL p_older_than_days DAY);
    COMMIT;
END //
DELIMITER ;

-- ===========================
-- Maintenance: cleanup orphaned carts/items on a schedule (you can run this via cron/ event scheduler)
-- You can enable event scheduler and create an event if desired.
-- Example (commented): enable if you want automatic monthly cleanup
-- ===========================
/*
SET GLOBAL event_scheduler = ON;
DROP EVENT IF EXISTS ev_cleanup_orphans;
CREATE EVENT ev_cleanup_orphans
ON SCHEDULE EVERY 7 DAY
DO
  CALL sp_cleanup_orphaned_records();
*/

-- ===========================
-- End of Part 3
-- ===========================
